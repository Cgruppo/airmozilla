import time

from django import http
from django.conf import settings
from django.shortcuts import redirect, render
from django.contrib.auth.decorators import login_required
from django.core.cache import cache

from jsonview.decorators import json_view

from airmozilla.base import mozillians


def debugger__(request):  # pragma: no cover
    r = http.HttpResponse()
    r.write('Todays date: 2014-05-21 14:02 PST\n')
    r.write('Request secure? %s\n' % request.is_secure())
    r.write('settings.COOKIES_SECURE? %s\n' % settings.COOKIES_SECURE)
    r['Content-Type'] = 'text/plain'
    if request.session.test_cookie_worked():
        r.write('Test cookie worked.\n')
        request.session.delete_test_cookie()
    else:
        request.session.set_test_cookie()
        r.write('Set a test cookie. Refresh to see if it stuck\n')
    if cache.get('__debugger__'):
        r.write('Cache framework works.\n')
    else:
        cache.set('__debugger__', time.time(), 10)
        r.write('Refresh to see if the cache framework works.\n')
    return r


def god_mode(request):
    if not (settings.DEBUG and settings.GOD_MODE):
        raise http.Http404()

    if request.method == 'POST':
        from django.contrib.auth.models import User
        user = User.objects.get(email__iexact=request.POST['email'])
        from django.contrib import auth
        user.backend = 'django.contrib.auth.backends.ModelBackend'
        auth.login(request, user)
        return redirect('/')

    context = {}
    return render(request, 'main/god_mode.html', context)


def edgecast_smil(request):
    context = {}
    for key, value in request.GET.items():
        context[key] = value
    response = render(request, 'main/edgecast_smil.xml', context)
    response['Content-Type'] = 'application/smil'
    response['Access-Control-Allow-Origin'] = '*'
    return response


@login_required
@json_view
def curated_groups_autocomplete(request):
    if 'q' not in request.GET:
        return http.HttpResponseBadRequest('q')
    q = request.GET.get('q', '').strip()
    if not q:
        return {'groups': []}

    all_ = mozillians.get_all_groups(name=q)
    ids = [x['id'] for x in all_]
    all_.extend([
        x for x in mozillians.get_all_groups(name_search=q)
        if x['id'] not in ids
    ])

    def describe_group(group):
        if group['member_count'] == 1:
            return '%s (1 member)' % (group['name'],)
        else:
            return (
                '%s (%s members)' % (group['name'], group['member_count'])
            )

    groups = [
        (x['name'], describe_group(x))
        for x in all_
    ]
    # naively sort by how good the match is
    groups.sort(key=lambda x: x[0].lower().find(q.lower()))
    return {'groups': groups}
